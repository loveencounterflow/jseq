// Generated by CoffeeScript 1.7.1
(function() {
  var TRM, alert, badge, debug, echo, help, info, log, rpr, warn, whisper;

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = 'jsEq/tests';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  echo = TRM.echo.bind(TRM);

  module.exports = function(eq, ne) {
    var R;
    R = {};

    /* 1. simple tests */

    /* 1.1. positive */
    R["NaN eqs NaN"] = function() {
      return eq(NaN, NaN);
    };
    R["finite integer n eqs n"] = function() {
      return eq(1234, 1234);
    };
    R["emtpy list eqs empty list"] = function() {
      return eq([], []);
    };
    R["emtpy obj eqs empty obj"] = function() {
      return eq({}, {});
    };
    R["number eqs number of same value"] = function() {
      return eq(123.45678, 123.45678);
    };
    R["regex lit's w same pattern, flags are eq"] = function() {
      return eq(/^abc[a-zA-Z]/, /^abc[a-zA-Z]/);
    };
    R["pods w same properties are eq"] = function() {
      return eq({
        a: 'b',
        c: 'd'
      }, {
        a: 'b',
        c: 'd'
      });
    };
    R["pods that only differ wrt prop ord are eq"] = function() {
      return eq({
        a: 'b',
        c: 'd'
      }, {
        c: 'd',
        a: 'b'
      });
    };

    /* 1.2. negative */
    R["obj doesn't eq list"] = function() {
      return ne({}, []);
    };
    R["obj in a list doesn't eq list in list"] = function() {
      return ne([{}], [[]]);
    };
    R["integer n doesn't eq rpr n"] = function() {
      return ne(1234, '1234');
    };
    R["integer n doesn't eq n + 1"] = function() {
      return ne(1234, 1235);
    };
    R["empty list doesn't eq false"] = function() {
      return ne([], false);
    };
    R["list w an integer doesn't eq one w rpr n"] = function() {
      return ne([3], ['3']);
    };
    R["regex lit's w diff. patterns, same flags aren't eq"] = function() {
      return ne(/^abc[a-zA-Z]/, /^abc[a-zA-Z]x/);
    };
    R["regex lit's w same patterns, diff. flags aren't eq"] = function() {
      return ne(/^abc[a-zA-Z]/, /^abc[a-zA-Z]/i);
    };
    R["+0 should ne -0"] = function() {
      return ne(+0, -0);
    };
    R["number obj not eqs primitive number of same value"] = function() {
      return ne(5, new Number(5));
    };
    R["string obj not eqs primitive string of same value"] = function() {
      return ne('helo', new String('helo'));
    };
    R["(1) bool obj not eqs primitive bool of same value"] = function() {
      return ne(false, new Boolean(false));
    };
    R["(2) bool obj not eqs primitive bool of same value"] = function() {
      return ne(true, new Boolean(true));
    };

    /* 2. complex tests */
    R["obj w undef member not eqs other obj w/out same member"] = function() {
      var d, e;
      d = {
        x: void 0
      };
      e = {};
      return ne(d, e);
    };
    R["fn1: functions w same source are eq"] = function() {
      var d, e;
      d = function( a, b, c ){ return a * b * c; };
      e = function( a, b, c ){ return a * b * c; };
      return eq(d, e);
    };
    R["fn2: functions w diff source aren't eq"] = function() {
      var d, e;
      d = function( a, b, c ){ return a * b * c; };
      e = function( a, b, c ){ return a  *  b  *  c; };
      return ne(d, e);
    };
    R["fn3: equal functions w equal props are eq"] = function() {
      var d, e;
      d = function() {
        return null;
      };
      d.foo = {
        some: 'meaningless',
        properties: 'here'
      };
      e = function() {
        return null;
      };
      e.foo = {
        some: 'meaningless',
        properties: 'here'
      };
      return eq(d, e);
    };
    R["fn4: equal functions w unequal props aren't eq"] = function() {
      var d, e;
      d = function() {
        return null;
      };
      d.foo = {
        some: 'meaningless',
        properties: 'here'
      };
      e = function() {
        return null;
      };
      e.foo = {
        some: 'meaningless',
        properties: 'here!!!'
      };
      return ne(d, e);
    };
    R["list w named member eqs other list w same member"] = function() {
      var d, e;
      d = ['foo', null, 3];
      d['extra'] = 42;
      e = ['foo', null, 3];
      e['extra'] = 42;
      return eq(d, e);
    };
    R["list w named member doesn't eq list w same member, other value"] = function() {
      var d, e;
      d = ['foo', null, 3];
      d['extra'] = 42;
      e = ['foo', null, 3];
      e['extra'] = 108;
      return ne(d, e);
    };
    R["date eqs other date pointing to same time"] = function() {
      var d, e;
      d = new Date("1995-12-17T03:24:00");
      e = new Date("1995-12-17T03:24:00");
      return eq(d, e);
    };
    R["date does not eq other date pointing to other time"] = function() {
      var d, e;
      d = new Date("1995-12-17T03:24:00");
      e = new Date("1995-12-17T03:24:01");
      return ne(d, e);
    };
    R["str obj w props eq same str, same props"] = function() {
      var d, e;
      d = new String("helo test");
      d['abc'] = 42;
      e = new String("helo test");
      e['abc'] = 42;
      return ne(d, e);
    };
    R["str obj w props not eq same str, other props"] = function() {
      var d, e;
      d = new String("helo test");
      d['abc'] = 42;
      e = new String("helo test");
      e['def'] = 42;
      return ne(d, e);
    };
    R["str obj w props eq same str, same props (circ)"] = function() {
      var c, d, e;
      c = ['a list'];
      c.push(c);
      d = new String("helo test");
      d['abc'] = c;
      e = new String("helo test");
      e['abc'] = c;
      return ne(d, e);
    };
    R["str obj w props not eq same str, other props (circ)"] = function() {
      var c, d, e;
      c = ['a list'];
      c.push(c);
      d = new String("helo test");
      d['abc'] = c;
      e = new String("helo test");
      e['def'] = c;
      return ne(d, e);
    };
    R["(1) circ arrays w same layout, same values are eq"] = function() {
      var d, e;
      d = [1, 2, 3];
      d.push(d);
      e = [1, 2, 3];
      e.push(d);
      return eq(d, e);
    };
    R["(2) circ arrays w same layout, same values are eq"] = function() {
      var d, e;
      d = [1, 2, 3];
      d.push(d);
      e = [1, 2, 3];
      e.push(e);
      return eq(d, e);
    };
    R["(fkling1) arrays w eq subarrays are eq"] = function() {
      var a, b, bar, foo;
      a = [1, 2, 3];
      b = [1, 2, 3];
      foo = [a, a];
      bar = [b, b];
      return eq(foo, bar);
    };
    R["(fkling2) arrays w eq subarrays but diff distribution aren't eq"] = function() {
      var a, b, bar, foo;
      a = [1, 2, 3];
      b = [1, 2, 3];
      foo = [a, a];
      bar = [a, b];
      return ne(foo, bar);
    };

    /* joshwilsdon's test (https://github.com/joyent/node/issues/7161) */
    R["joshwilsdon"] = function() {
      var count, d1, d2, errors, idx1, idx2, v1, v2, _i, _j, _len, _ref;
      d1 = [
        NaN, void 0, null, true, false, Infinity, 0, 1, "a", "b", {
          a: 1
        }, {
          a: "a"
        }, [
          {
            a: 1
          }
        ], [
          {
            a: true
          }
        ], {
          a: 1,
          b: 2
        }, [1, 2], [1, 2, 3], {
          a: "1"
        }, {
          a: "1",
          b: "2"
        }
      ];
      d2 = [
        NaN, void 0, null, true, false, Infinity, 0, 1, "a", "b", {
          a: 1
        }, {
          a: "a"
        }, [
          {
            a: 1
          }
        ], [
          {
            a: true
          }
        ], {
          a: 1,
          b: 2
        }, [1, 2], [1, 2, 3], {
          a: "1"
        }, {
          a: "1",
          b: "2"
        }
      ];
      errors = [];
      count = 0;
      for (idx1 = _i = 0, _len = d1.length; _i < _len; idx1 = ++_i) {
        v1 = d1[idx1];
        for (idx2 = _j = idx1, _ref = d2.length; idx1 <= _ref ? _j < _ref : _j > _ref; idx2 = idx1 <= _ref ? ++_j : --_j) {
          count += 1;
          v2 = d2[idx2];
          if (idx1 === idx2) {
            if (!eq(v1, v2)) {
              errors.push("eq " + (rpr(v1)) + ", " + (rpr(v2)));
            }
          } else {
            if (!ne(v1, v2)) {
              errors.push("ne " + (rpr(v1)) + ", " + (rpr(v2)));
            }
          }
        }
      }
      return [count, errors];
    };
    return R;
  };

}).call(this);
